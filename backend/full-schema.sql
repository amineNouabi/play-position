-- Enable the postgis extension for geospatial data
DROP EXTENSION IF EXISTS postgis CASCADE;
CREATE EXTENSION postgis WITH SCHEMA extensions;

-- Custom enum types
CREATE TYPE public.app_role as enum ('Admin', 'Player');

CREATE TYPE public.app_permission as enum (
	'profiles.insert', 'profiles.update', 'profiles.delete',
	'games.insert', 'games.update', 'games.delete'
);

-- Role Permissions
DROP TABLE IF EXISTS public.role_permissions CASCADE;
CREATE TABLE public.role_permissions (
	id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	role app_role NOT NULL,
	permission app_permission NOT NULL,
	UNIQUE (role, permission)
);

-- Create Profiles Table
DROP TABLE IF EXISTS public.profiles CASCADE;
CREATE TABLE public.profiles (
	id UUID REFERENCES auth.users ON DELETE CASCADE NOT NULL PRIMARY KEY,
	created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
	updated_at TIMESTAMP WITH TIME ZONE NULL DEFAULT NOW(),
	email TEXT NULL,
	phone TEXT NULL,
	full_name TEXT NULL,
	avatar TEXT NULL
);

COMMENT ON TABLE public.profiles IS 'Profile data for each user.';
COMMENT ON COLUMN public.profiles.id IS 'References the internal Supabase Auth user.';

-- User Roles
CREATE TABLE public.profile_roles (
	id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	profile_id UUID REFERENCES public.profiles ON DELETE CASCADE NOT NULL,
	role app_role NOT NULL,
	UNIQUE (profile_id, role)
);

COMMENT ON TABLE public.profile_roles IS 'Application roles for each profile.';

--Create Games Table
DROP TABLE IF EXISTS public.games CASCADE;
CREATE TABLE public.games (
	id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
	profile_id UUID REFERENCES public.profiles ON DELETE CASCADE NOT NULL,
	created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
	updated_at TIMESTAMP WITH TIME ZONE NULL DEFAULT NOW(),
	players_per_team INT NOT NULL,
	pre_taken_spots_team_a INT NOT NULL DEFAULT 0 CHECK (pre_taken_spots_team_a >= 0 AND pre_taken_spots_team_a <= players_per_team),
	pre_taken_spots_team_b INT NOT NULL DEFAULT 0 CHECK (pre_taken_spots_team_b >= 0 AND pre_taken_spots_team_b <= players_per_team),
	location GEOMETRY(POINT) NOT NULL,
	start_time TIMESTAMP WITH TIME ZONE NOT NULL
);

COMMENT ON TABLE public.games IS 'Soccer Games created by users.';

CREATE INDEX games_location_idx ON public.games USING GIST (location);

-- Authorize with role-based access control (RBAC)
CREATE OR REPLACE FUNCTION public.authorize(
	requested_permission app_permission,
	profile_id UUID
)
RETURNS BOOLEAN AS $$
DECLARE
	bind_permissions INT;
BEGIN
	SELECT COUNT(*)
	FROM public.role_permissions
	INNER JOIN public.profile_roles ON role_permissions.role = profile_roles.role
	WHERE role_permissions.permission = requested_permission
		AND profile_roles.profile_id = profile_id
	INTO bind_permissions;

	RETURN bind_permissions > 0;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Get the user roles and permissions
CREATE OR REPLACE FUNCTION public.user_roles_and_permissions(
	p_profile_id UUID
)
RETURNS TABLE (
	role app_role,
	permission app_permission
) AS $$
BEGIN
	RETURN QUERY
	SELECT
		profile_roles.role,
		role_permissions.permission
	FROM public.profile_roles
	INNER JOIN public.role_permissions ON profile_roles.role = role_permissions.role
	WHERE profile_roles.profile_id = p_profile_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- -- Secure the tables by Enabling the Row Level Security
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.games ENABLE ROW LEVEL SECURITY;

-- Create policies for profiles
CREATE POLICY "Allow logged-in read access" ON public.profiles FOR SELECT USING ( auth.role() = 'authenticated' );
CREATE POLICY "Allow authorized insert access" ON public.profiles FOR INSERT WITH CHECK ( (auth.uid() = id) OR authorize('profiles.insert', auth.uid()) );
CREATE POLICY "Allow authorized update access" ON public.profiles FOR UPDATE USING ( (auth.uid() = id) OR authorize('profiles.update', auth.uid()) );
CREATE POLICY "Allow authorized delete access" ON public.profiles FOR DELETE USING ( (auth.uid() = id) OR authorize('profiles.delete', auth.uid()) );

-- Create policies for games
CREATE POLICY "Allow logged-in read access" ON public.games FOR SELECT USING ( auth.role() = 'authenticated' );
CREATE POLICY "Allow authorized insert access" ON public.games FOR INSERT WITH CHECK ( authorize('games.insert', auth.uid()) );
CREATE POLICY "Allow authorized update access" ON public.games FOR UPDATE USING ( authorize('games.update', auth.uid()) );
CREATE POLICY "Allow authorized delete access" ON public.games FOR DELETE USING ( ( auth.uid() = profile_id ) OR authorize('games.delete', auth.uid()) );



-- Create trigger function to handle new user creation
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER
LANGUAGE PLPGSQL
SECURITY DEFINER SET search_path = ''
AS $$
BEGIN
	INSERT INTO public.profiles (id, full_name, email, avatar)
	VALUES (new.id, new.raw_user_meta_data ->> 'full_name', new.email, new.raw_user_meta_data ->> 'avatar_url');
	INSERT INTO public.profile_roles (profile_id, role) VALUES (new.id, 'Player');
	RETURN new;
END;
$$;

-- trigger the function every time a user is created
CREATE TRIGGER on_auth_user_created
	AFTER INSERT ON auth.users
	FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();


-- Admin Permissions
INSERT INTO public.role_permissions (role, permission)
VALUES ('Admin', 'profiles.insert'), ('Admin', 'profiles.update'), ('Admin', 'profiles.delete'),
	('Admin', 'games.insert'), ('Admin', 'games.update'), ('Admin', 'games.delete');

-- Player Permissions
INSERT INTO public.role_permissions (role, permission)
VALUES ('Player', 'games.insert'), ('Player', 'games.update');
